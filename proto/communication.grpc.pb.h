// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: communication.proto
#ifndef GRPC_communication_2eproto__INCLUDED
#define GRPC_communication_2eproto__INCLUDED

#include "communication.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace communication {

// 机器人信息
class RobotComm final {
 public:
  static constexpr char const* service_full_name() {
    return "communication.RobotComm";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // ! GET Method
    // 向服务器索取血量信息 传回血量信息
    virtual ::grpc::Status GetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Blood* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>> AsyncGetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>>(AsyncGetBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>> PrepareAsyncGetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>>(PrepareAsyncGetBloodRaw(context, request, cq));
    }
    // 向服务器索取弹药量信息 传回弹药量信息
    virtual ::grpc::Status GetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Bullet* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Bullet>> AsyncGetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Bullet>>(AsyncGetBulletRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Bullet>> PrepareAsyncGetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Bullet>>(PrepareAsyncGetBulletRaw(context, request, cq));
    }
    // 向服务器索取位姿信息 传回位姿信息
    virtual ::grpc::Status GetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Posture* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>> AsyncGetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>>(AsyncGetPostureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>> PrepareAsyncGetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>>(PrepareAsyncGetPostureRaw(context, request, cq));
    }
    // 向服务器索取枪口朝向信息 传回枪口朝向信息
    virtual ::grpc::Status GetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::GimbalYaw* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GimbalYaw>> AsyncGetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GimbalYaw>>(AsyncGetGimbalYawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GimbalYaw>> PrepareAsyncGetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GimbalYaw>>(PrepareAsyncGetGimbalYawRaw(context, request, cq));
    }
    // 向服务器索取速度信息 传回速度信息
    virtual ::grpc::Status GetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Velocity* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>> AsyncGetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>>(AsyncGetVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>> PrepareAsyncGetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>>(PrepareAsyncGetVelocityRaw(context, request, cq));
    }
    // 向服务器索取受击信息 传回受击信息
    virtual ::grpc::Status GetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Attacked* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Attacked>> AsyncGetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Attacked>>(AsyncGetAttackedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Attacked>> PrepareAsyncGetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Attacked>>(PrepareAsyncGetAttackedRaw(context, request, cq));
    }
    // 向服务器索取位置信息 传回位置信息
    virtual ::grpc::Status GetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::ObjectDection* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>> AsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>>(AsyncGetObjectDectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>> PrepareAsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>>(PrepareAsyncGetObjectDectionRaw(context, request, cq));
    }
    // ! POST Method
    // 向服务器传输血量信息 传回是否正确设置
    virtual ::grpc::Status PostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostBloodRaw(context, request, cq));
    }
    // 向服务器传输弹药量信息 传回是否正确设置
    virtual ::grpc::Status PostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostBulletRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostBulletRaw(context, request, cq));
    }
    // 向服务器传输目的地信息 传回是否正确设置
    virtual ::grpc::Status PostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostDestinationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostDestinationRaw(context, request, cq));
    }
    // 向服务器传输摩擦轮信息 传回是否正确设置
    virtual ::grpc::Status PostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostFricWheelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostFricWheelRaw(context, request, cq));
    }
    // 向服务器传输停止信息 传回是否正确设置
    virtual ::grpc::Status PostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostChassisStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostChassisStopRaw(context, request, cq));
    }
    // 向服务器传输子弹开关信息 传回是否正确设置
    virtual ::grpc::Status PostShooter(::grpc::ClientContext* context, const ::communication::Shooter& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostShooter(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostShooterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostShooter(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostShooterRaw(context, request, cq));
    }
    // 向服务器传递系统开启的指令
    virtual ::grpc::Status PostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostSystemRunRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostSystemRunRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // ! GET Method
      // 向服务器索取血量信息 传回血量信息
      virtual void GetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Blood* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Blood* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取弹药量信息 传回弹药量信息
      virtual void GetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Bullet* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Bullet* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取位姿信息 传回位姿信息
      virtual void GetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Posture* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Posture* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取枪口朝向信息 传回枪口朝向信息
      virtual void GetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::GimbalYaw* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::GimbalYaw* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取速度信息 传回速度信息
      virtual void GetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Velocity* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Velocity* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取受击信息 传回受击信息
      virtual void GetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Attacked* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Attacked* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取位置信息 传回位置信息
      virtual void GetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::ObjectDection* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::ObjectDection* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ! POST Method
      // 向服务器传输血量信息 传回是否正确设置
      virtual void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输弹药量信息 传回是否正确设置
      virtual void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输目的地信息 传回是否正确设置
      virtual void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输摩擦轮信息 传回是否正确设置
      virtual void PostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输停止信息 传回是否正确设置
      virtual void PostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输子弹开关信息 传回是否正确设置
      virtual void PostShooter(::grpc::ClientContext* context, const ::communication::Shooter* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostShooter(::grpc::ClientContext* context, const ::communication::Shooter* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传递系统开启的指令
      virtual void PostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>* AsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>* PrepareAsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Bullet>* AsyncGetBulletRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Bullet>* PrepareAsyncGetBulletRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>* AsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>* PrepareAsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::GimbalYaw>* AsyncGetGimbalYawRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::GimbalYaw>* PrepareAsyncGetGimbalYawRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>* AsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>* PrepareAsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Attacked>* AsyncGetAttackedRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Attacked>* PrepareAsyncGetAttackedRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>* AsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>* PrepareAsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostFricWheelRaw(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostFricWheelRaw(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostChassisStopRaw(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostChassisStopRaw(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostShooterRaw(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostShooterRaw(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostSystemRunRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostSystemRunRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Blood* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>> AsyncGetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>>(AsyncGetBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>> PrepareAsyncGetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>>(PrepareAsyncGetBloodRaw(context, request, cq));
    }
    ::grpc::Status GetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Bullet* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Bullet>> AsyncGetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Bullet>>(AsyncGetBulletRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Bullet>> PrepareAsyncGetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Bullet>>(PrepareAsyncGetBulletRaw(context, request, cq));
    }
    ::grpc::Status GetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Posture* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>> AsyncGetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>>(AsyncGetPostureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>> PrepareAsyncGetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>>(PrepareAsyncGetPostureRaw(context, request, cq));
    }
    ::grpc::Status GetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::GimbalYaw* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GimbalYaw>> AsyncGetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GimbalYaw>>(AsyncGetGimbalYawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GimbalYaw>> PrepareAsyncGetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GimbalYaw>>(PrepareAsyncGetGimbalYawRaw(context, request, cq));
    }
    ::grpc::Status GetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Velocity* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>> AsyncGetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>>(AsyncGetVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>> PrepareAsyncGetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>>(PrepareAsyncGetVelocityRaw(context, request, cq));
    }
    ::grpc::Status GetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Attacked* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Attacked>> AsyncGetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Attacked>>(AsyncGetAttackedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Attacked>> PrepareAsyncGetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Attacked>>(PrepareAsyncGetAttackedRaw(context, request, cq));
    }
    ::grpc::Status GetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::ObjectDection* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>> AsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>>(AsyncGetObjectDectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>> PrepareAsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>>(PrepareAsyncGetObjectDectionRaw(context, request, cq));
    }
    ::grpc::Status PostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostBloodRaw(context, request, cq));
    }
    ::grpc::Status PostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostBulletRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostBulletRaw(context, request, cq));
    }
    ::grpc::Status PostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostDestinationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostDestinationRaw(context, request, cq));
    }
    ::grpc::Status PostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostFricWheelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostFricWheelRaw(context, request, cq));
    }
    ::grpc::Status PostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostChassisStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostChassisStopRaw(context, request, cq));
    }
    ::grpc::Status PostShooter(::grpc::ClientContext* context, const ::communication::Shooter& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostShooter(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostShooterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostShooter(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostShooterRaw(context, request, cq));
    }
    ::grpc::Status PostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostSystemRunRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostSystemRunRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Blood* response, std::function<void(::grpc::Status)>) override;
      void GetBlood(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Blood* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Bullet* response, std::function<void(::grpc::Status)>) override;
      void GetBullet(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Bullet* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Posture* response, std::function<void(::grpc::Status)>) override;
      void GetPosture(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Posture* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::GimbalYaw* response, std::function<void(::grpc::Status)>) override;
      void GetGimbalYaw(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::GimbalYaw* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Velocity* response, std::function<void(::grpc::Status)>) override;
      void GetVelocity(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Velocity* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Attacked* response, std::function<void(::grpc::Status)>) override;
      void GetAttacked(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Attacked* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::ObjectDection* response, std::function<void(::grpc::Status)>) override;
      void GetObjectDection(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::ObjectDection* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostFricWheel(::grpc::ClientContext* context, const ::communication::FricWheel* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostChassisStop(::grpc::ClientContext* context, const ::communication::ChassisStop* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostShooter(::grpc::ClientContext* context, const ::communication::Shooter* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostShooter(::grpc::ClientContext* context, const ::communication::Shooter* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostSystemRun(::grpc::ClientContext* context, const ::communication::CommonRequest* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::communication::Blood>* AsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Blood>* PrepareAsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Bullet>* AsyncGetBulletRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Bullet>* PrepareAsyncGetBulletRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Posture>* AsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Posture>* PrepareAsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::GimbalYaw>* AsyncGetGimbalYawRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::GimbalYaw>* PrepareAsyncGetGimbalYawRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Velocity>* AsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Velocity>* PrepareAsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Attacked>* AsyncGetAttackedRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Attacked>* PrepareAsyncGetAttackedRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>* AsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>* PrepareAsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostFricWheelRaw(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostFricWheelRaw(::grpc::ClientContext* context, const ::communication::FricWheel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostChassisStopRaw(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostChassisStopRaw(::grpc::ClientContext* context, const ::communication::ChassisStop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostShooterRaw(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostShooterRaw(::grpc::ClientContext* context, const ::communication::Shooter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostSystemRunRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostSystemRunRaw(::grpc::ClientContext* context, const ::communication::CommonRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlood_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBullet_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPosture_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGimbalYaw_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVelocity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAttacked_;
    const ::grpc::internal::RpcMethod rpcmethod_GetObjectDection_;
    const ::grpc::internal::RpcMethod rpcmethod_PostBlood_;
    const ::grpc::internal::RpcMethod rpcmethod_PostBullet_;
    const ::grpc::internal::RpcMethod rpcmethod_PostDestination_;
    const ::grpc::internal::RpcMethod rpcmethod_PostFricWheel_;
    const ::grpc::internal::RpcMethod rpcmethod_PostChassisStop_;
    const ::grpc::internal::RpcMethod rpcmethod_PostShooter_;
    const ::grpc::internal::RpcMethod rpcmethod_PostSystemRun_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // ! GET Method
    // 向服务器索取血量信息 传回血量信息
    virtual ::grpc::Status GetBlood(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::Blood* response);
    // 向服务器索取弹药量信息 传回弹药量信息
    virtual ::grpc::Status GetBullet(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::Bullet* response);
    // 向服务器索取位姿信息 传回位姿信息
    virtual ::grpc::Status GetPosture(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::Posture* response);
    // 向服务器索取枪口朝向信息 传回枪口朝向信息
    virtual ::grpc::Status GetGimbalYaw(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::GimbalYaw* response);
    // 向服务器索取速度信息 传回速度信息
    virtual ::grpc::Status GetVelocity(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::Velocity* response);
    // 向服务器索取受击信息 传回受击信息
    virtual ::grpc::Status GetAttacked(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::Attacked* response);
    // 向服务器索取位置信息 传回位置信息
    virtual ::grpc::Status GetObjectDection(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::ObjectDection* response);
    // ! POST Method
    // 向服务器传输血量信息 传回是否正确设置
    virtual ::grpc::Status PostBlood(::grpc::ServerContext* context, const ::communication::Blood* request, ::communication::Response* response);
    // 向服务器传输弹药量信息 传回是否正确设置
    virtual ::grpc::Status PostBullet(::grpc::ServerContext* context, const ::communication::Bullet* request, ::communication::Response* response);
    // 向服务器传输目的地信息 传回是否正确设置
    virtual ::grpc::Status PostDestination(::grpc::ServerContext* context, const ::communication::Destination* request, ::communication::Response* response);
    // 向服务器传输摩擦轮信息 传回是否正确设置
    virtual ::grpc::Status PostFricWheel(::grpc::ServerContext* context, const ::communication::FricWheel* request, ::communication::Response* response);
    // 向服务器传输停止信息 传回是否正确设置
    virtual ::grpc::Status PostChassisStop(::grpc::ServerContext* context, const ::communication::ChassisStop* request, ::communication::Response* response);
    // 向服务器传输子弹开关信息 传回是否正确设置
    virtual ::grpc::Status PostShooter(::grpc::ServerContext* context, const ::communication::Shooter* request, ::communication::Response* response);
    // 向服务器传递系统开启的指令
    virtual ::grpc::Status PostSystemRun(::grpc::ServerContext* context, const ::communication::CommonRequest* request, ::communication::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlood() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlood(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::Blood>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBullet() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBullet(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Bullet* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBullet(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::Bullet>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPosture() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosture(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::Posture>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGimbalYaw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGimbalYaw() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetGimbalYaw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGimbalYaw(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::GimbalYaw* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGimbalYaw(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::GimbalYaw>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVelocity() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVelocity(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::Velocity>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAttacked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAttacked() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetAttacked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAttacked(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Attacked* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAttacked(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::Attacked>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectDection(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::ObjectDection>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostBlood() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBlood(::grpc::ServerContext* context, ::communication::Blood* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostBullet() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBullet(::grpc::ServerContext* context, ::communication::Bullet* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostDestination() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostDestination(::grpc::ServerContext* context, ::communication::Destination* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostFricWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostFricWheel() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_PostFricWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFricWheel(::grpc::ServerContext* /*context*/, const ::communication::FricWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostFricWheel(::grpc::ServerContext* context, ::communication::FricWheel* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostChassisStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostChassisStop() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_PostChassisStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostChassisStop(::grpc::ServerContext* /*context*/, const ::communication::ChassisStop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostChassisStop(::grpc::ServerContext* context, ::communication::ChassisStop* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostShooter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostShooter() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_PostShooter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostShooter(::grpc::ServerContext* /*context*/, const ::communication::Shooter* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostShooter(::grpc::ServerContext* context, ::communication::Shooter* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostSystemRun : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostSystemRun() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_PostSystemRun() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSystemRun(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostSystemRun(::grpc::ServerContext* context, ::communication::CommonRequest* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetBlood<WithAsyncMethod_GetBullet<WithAsyncMethod_GetPosture<WithAsyncMethod_GetGimbalYaw<WithAsyncMethod_GetVelocity<WithAsyncMethod_GetAttacked<WithAsyncMethod_GetObjectDection<WithAsyncMethod_PostBlood<WithAsyncMethod_PostBullet<WithAsyncMethod_PostDestination<WithAsyncMethod_PostFricWheel<WithAsyncMethod_PostChassisStop<WithAsyncMethod_PostShooter<WithAsyncMethod_PostSystemRun<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlood() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Blood>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::Blood* response) { return this->GetBlood(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlood(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::Blood>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Blood>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Blood* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBullet() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Bullet>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::Bullet* response) { return this->GetBullet(context, request, response); }));}
    void SetMessageAllocatorFor_GetBullet(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::Bullet>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Bullet>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBullet(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Bullet* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBullet(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Bullet* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPosture() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Posture>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::Posture* response) { return this->GetPosture(context, request, response); }));}
    void SetMessageAllocatorFor_GetPosture(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::Posture>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Posture>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPosture(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Posture* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGimbalYaw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGimbalYaw() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::GimbalYaw>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::GimbalYaw* response) { return this->GetGimbalYaw(context, request, response); }));}
    void SetMessageAllocatorFor_GetGimbalYaw(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::GimbalYaw>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::GimbalYaw>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGimbalYaw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGimbalYaw(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::GimbalYaw* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGimbalYaw(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::GimbalYaw* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVelocity() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Velocity>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::Velocity* response) { return this->GetVelocity(context, request, response); }));}
    void SetMessageAllocatorFor_GetVelocity(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::Velocity>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Velocity>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Velocity* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAttacked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAttacked() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Attacked>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::Attacked* response) { return this->GetAttacked(context, request, response); }));}
    void SetMessageAllocatorFor_GetAttacked(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::Attacked>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Attacked>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAttacked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAttacked(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Attacked* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAttacked(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Attacked* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::ObjectDection>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::ObjectDection* response) { return this->GetObjectDection(context, request, response); }));}
    void SetMessageAllocatorFor_GetObjectDection(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::ObjectDection>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::ObjectDection>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetObjectDection(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::ObjectDection* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostBlood() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Blood, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Blood* request, ::communication::Response* response) { return this->PostBlood(context, request, response); }));}
    void SetMessageAllocatorFor_PostBlood(
        ::grpc::MessageAllocator< ::communication::Blood, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Blood, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostBullet() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Bullet, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Bullet* request, ::communication::Response* response) { return this->PostBullet(context, request, response); }));}
    void SetMessageAllocatorFor_PostBullet(
        ::grpc::MessageAllocator< ::communication::Bullet, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Bullet, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBullet(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostDestination() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Destination, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Destination* request, ::communication::Response* response) { return this->PostDestination(context, request, response); }));}
    void SetMessageAllocatorFor_PostDestination(
        ::grpc::MessageAllocator< ::communication::Destination, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Destination, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostDestination(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostFricWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostFricWheel() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::FricWheel, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::FricWheel* request, ::communication::Response* response) { return this->PostFricWheel(context, request, response); }));}
    void SetMessageAllocatorFor_PostFricWheel(
        ::grpc::MessageAllocator< ::communication::FricWheel, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::FricWheel, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostFricWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFricWheel(::grpc::ServerContext* /*context*/, const ::communication::FricWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostFricWheel(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::FricWheel* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostChassisStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostChassisStop() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::ChassisStop, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::ChassisStop* request, ::communication::Response* response) { return this->PostChassisStop(context, request, response); }));}
    void SetMessageAllocatorFor_PostChassisStop(
        ::grpc::MessageAllocator< ::communication::ChassisStop, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::ChassisStop, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostChassisStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostChassisStop(::grpc::ServerContext* /*context*/, const ::communication::ChassisStop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostChassisStop(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::ChassisStop* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostShooter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostShooter() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Shooter, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Shooter* request, ::communication::Response* response) { return this->PostShooter(context, request, response); }));}
    void SetMessageAllocatorFor_PostShooter(
        ::grpc::MessageAllocator< ::communication::Shooter, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Shooter, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostShooter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostShooter(::grpc::ServerContext* /*context*/, const ::communication::Shooter* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostShooter(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Shooter* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostSystemRun : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostSystemRun() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::CommonRequest* request, ::communication::Response* response) { return this->PostSystemRun(context, request, response); }));}
    void SetMessageAllocatorFor_PostSystemRun(
        ::grpc::MessageAllocator< ::communication::CommonRequest, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::CommonRequest, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostSystemRun() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSystemRun(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostSystemRun(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetBlood<WithCallbackMethod_GetBullet<WithCallbackMethod_GetPosture<WithCallbackMethod_GetGimbalYaw<WithCallbackMethod_GetVelocity<WithCallbackMethod_GetAttacked<WithCallbackMethod_GetObjectDection<WithCallbackMethod_PostBlood<WithCallbackMethod_PostBullet<WithCallbackMethod_PostDestination<WithCallbackMethod_PostFricWheel<WithCallbackMethod_PostChassisStop<WithCallbackMethod_PostShooter<WithCallbackMethod_PostSystemRun<Service > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlood() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBullet() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBullet(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Bullet* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPosture() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGimbalYaw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGimbalYaw() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetGimbalYaw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGimbalYaw(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::GimbalYaw* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVelocity() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAttacked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAttacked() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetAttacked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAttacked(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Attacked* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostBlood() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostBullet() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostDestination() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostFricWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostFricWheel() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_PostFricWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFricWheel(::grpc::ServerContext* /*context*/, const ::communication::FricWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostChassisStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostChassisStop() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_PostChassisStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostChassisStop(::grpc::ServerContext* /*context*/, const ::communication::ChassisStop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostShooter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostShooter() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_PostShooter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostShooter(::grpc::ServerContext* /*context*/, const ::communication::Shooter* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostSystemRun : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostSystemRun() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_PostSystemRun() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSystemRun(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlood() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlood(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBullet() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBullet(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Bullet* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBullet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPosture() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosture(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGimbalYaw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGimbalYaw() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetGimbalYaw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGimbalYaw(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::GimbalYaw* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGimbalYaw(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVelocity() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVelocity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAttacked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAttacked() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetAttacked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAttacked(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Attacked* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAttacked(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectDection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostBlood() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBlood(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostBullet() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBullet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostDestination() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostDestination(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostFricWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostFricWheel() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_PostFricWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFricWheel(::grpc::ServerContext* /*context*/, const ::communication::FricWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostFricWheel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostChassisStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostChassisStop() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_PostChassisStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostChassisStop(::grpc::ServerContext* /*context*/, const ::communication::ChassisStop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostChassisStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostShooter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostShooter() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_PostShooter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostShooter(::grpc::ServerContext* /*context*/, const ::communication::Shooter* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostShooter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostSystemRun : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostSystemRun() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_PostSystemRun() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSystemRun(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostSystemRun(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlood() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlood(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBullet() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBullet(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBullet(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Bullet* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBullet(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPosture() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPosture(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPosture(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGimbalYaw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGimbalYaw() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGimbalYaw(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGimbalYaw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGimbalYaw(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::GimbalYaw* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGimbalYaw(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVelocity() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVelocity(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAttacked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAttacked() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAttacked(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAttacked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAttacked(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Attacked* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAttacked(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetObjectDection(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetObjectDection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostBlood() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostBlood(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostBullet() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostBullet(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBullet(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostDestination() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostDestination(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostDestination(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostFricWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostFricWheel() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostFricWheel(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostFricWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFricWheel(::grpc::ServerContext* /*context*/, const ::communication::FricWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostFricWheel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostChassisStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostChassisStop() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostChassisStop(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostChassisStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostChassisStop(::grpc::ServerContext* /*context*/, const ::communication::ChassisStop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostChassisStop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostShooter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostShooter() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostShooter(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostShooter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostShooter(::grpc::ServerContext* /*context*/, const ::communication::Shooter* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostShooter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostSystemRun : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostSystemRun() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostSystemRun(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostSystemRun() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostSystemRun(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostSystemRun(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlood() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::Blood>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::Blood>* streamer) {
                       return this->StreamedGetBlood(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlood(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::Blood>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBullet() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::Bullet>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::Bullet>* streamer) {
                       return this->StreamedGetBullet(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBullet(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Bullet* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBullet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::Bullet>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPosture() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::Posture>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::Posture>* streamer) {
                       return this->StreamedGetPosture(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPosture(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::Posture>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGimbalYaw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGimbalYaw() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::GimbalYaw>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::GimbalYaw>* streamer) {
                       return this->StreamedGetGimbalYaw(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGimbalYaw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGimbalYaw(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::GimbalYaw* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGimbalYaw(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::GimbalYaw>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVelocity() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::Velocity>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::Velocity>* streamer) {
                       return this->StreamedGetVelocity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVelocity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::Velocity>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAttacked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAttacked() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::Attacked>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::Attacked>* streamer) {
                       return this->StreamedGetAttacked(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAttacked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAttacked(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Attacked* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAttacked(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::Attacked>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::ObjectDection>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::ObjectDection>* streamer) {
                       return this->StreamedGetObjectDection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetObjectDection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::ObjectDection>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostBlood() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Blood, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Blood, ::communication::Response>* streamer) {
                       return this->StreamedPostBlood(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostBlood(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Blood,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostBullet() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Bullet, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Bullet, ::communication::Response>* streamer) {
                       return this->StreamedPostBullet(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostBullet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Bullet,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostDestination() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Destination, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Destination, ::communication::Response>* streamer) {
                       return this->StreamedPostDestination(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostDestination(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Destination,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostFricWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostFricWheel() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::FricWheel, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::FricWheel, ::communication::Response>* streamer) {
                       return this->StreamedPostFricWheel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostFricWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostFricWheel(::grpc::ServerContext* /*context*/, const ::communication::FricWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostFricWheel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::FricWheel,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostChassisStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostChassisStop() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::ChassisStop, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::ChassisStop, ::communication::Response>* streamer) {
                       return this->StreamedPostChassisStop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostChassisStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostChassisStop(::grpc::ServerContext* /*context*/, const ::communication::ChassisStop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostChassisStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::ChassisStop,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostShooter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostShooter() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Shooter, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Shooter, ::communication::Response>* streamer) {
                       return this->StreamedPostShooter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostShooter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostShooter(::grpc::ServerContext* /*context*/, const ::communication::Shooter* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostShooter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Shooter,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostSystemRun : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostSystemRun() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::CommonRequest, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::CommonRequest, ::communication::Response>* streamer) {
                       return this->StreamedPostSystemRun(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostSystemRun() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostSystemRun(::grpc::ServerContext* /*context*/, const ::communication::CommonRequest* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostSystemRun(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::CommonRequest,::communication::Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetBlood<WithStreamedUnaryMethod_GetBullet<WithStreamedUnaryMethod_GetPosture<WithStreamedUnaryMethod_GetGimbalYaw<WithStreamedUnaryMethod_GetVelocity<WithStreamedUnaryMethod_GetAttacked<WithStreamedUnaryMethod_GetObjectDection<WithStreamedUnaryMethod_PostBlood<WithStreamedUnaryMethod_PostBullet<WithStreamedUnaryMethod_PostDestination<WithStreamedUnaryMethod_PostFricWheel<WithStreamedUnaryMethod_PostChassisStop<WithStreamedUnaryMethod_PostShooter<WithStreamedUnaryMethod_PostSystemRun<Service > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetBlood<WithStreamedUnaryMethod_GetBullet<WithStreamedUnaryMethod_GetPosture<WithStreamedUnaryMethod_GetGimbalYaw<WithStreamedUnaryMethod_GetVelocity<WithStreamedUnaryMethod_GetAttacked<WithStreamedUnaryMethod_GetObjectDection<WithStreamedUnaryMethod_PostBlood<WithStreamedUnaryMethod_PostBullet<WithStreamedUnaryMethod_PostDestination<WithStreamedUnaryMethod_PostFricWheel<WithStreamedUnaryMethod_PostChassisStop<WithStreamedUnaryMethod_PostShooter<WithStreamedUnaryMethod_PostSystemRun<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace communication


#endif  // GRPC_communication_2eproto__INCLUDED
