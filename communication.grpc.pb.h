// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: communication.proto
#ifndef GRPC_communication_2eproto__INCLUDED
#define GRPC_communication_2eproto__INCLUDED

#include "communication.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace communication {

class RobotComm final {
 public:
  static constexpr char const* service_full_name() {
    return "communication.RobotComm";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 向服务器索取血量信息 传回血量信息
    virtual ::grpc::Status GetBlood(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Blood* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>> AsyncGetBlood(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>>(AsyncGetBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>> PrepareAsyncGetBlood(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>>(PrepareAsyncGetBloodRaw(context, request, cq));
    }
    // 向服务器索取弹药量信息 传回弹药量信息
    virtual ::grpc::Status GetAmmunition(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Ammunition* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Ammunition>> AsyncGetAmmunition(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Ammunition>>(AsyncGetAmmunitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Ammunition>> PrepareAsyncGetAmmunition(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Ammunition>>(PrepareAsyncGetAmmunitionRaw(context, request, cq));
    }
    // 向服务器索取位姿信息 传回位姿信息
    virtual ::grpc::Status GetPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Posture* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>> AsyncGetPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>>(AsyncGetPostureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>> PrepareAsyncGetPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>>(PrepareAsyncGetPostureRaw(context, request, cq));
    }
    // 向服务器索取枪口朝向信息 传回枪口朝向信息
    virtual ::grpc::Status GetGunPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::GunPosture* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GunPosture>> AsyncGetGunPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GunPosture>>(AsyncGetGunPostureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GunPosture>> PrepareAsyncGetGunPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::GunPosture>>(PrepareAsyncGetGunPostureRaw(context, request, cq));
    }
    // 向服务器索取速度信息 传回速度信息
    virtual ::grpc::Status GetVelocity(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Velocity* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>> AsyncGetVelocity(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>>(AsyncGetVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>> PrepareAsyncGetVelocity(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>>(PrepareAsyncGetVelocityRaw(context, request, cq));
    }
    // 向服务器索取受击信息 传回受击信息
    virtual ::grpc::Status GetAffected(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Affected* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Affected>> AsyncGetAffected(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Affected>>(AsyncGetAffectedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Affected>> PrepareAsyncGetAffected(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Affected>>(PrepareAsyncGetAffectedRaw(context, request, cq));
    }
    // 向服务器索取位置信息 传回位置信息
    virtual ::grpc::Status GetObjectDection(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::ObjectDection* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>> AsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>>(AsyncGetObjectDectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>> PrepareAsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>>(PrepareAsyncGetObjectDectionRaw(context, request, cq));
    }
    // 向服务器传输血量信息 传回是否正确设置
    virtual ::grpc::Status PostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostBloodRaw(context, request, cq));
    }
    // 向服务器传输弹药量信息 传回是否正确设置
    virtual ::grpc::Status PostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostAmmunitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostAmmunitionRaw(context, request, cq));
    }
    // 向服务器传输目的地信息 传回是否正确设置
    virtual ::grpc::Status PostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostDestinationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostDestinationRaw(context, request, cq));
    }
    // 向服务器传输摩擦轮信息 传回是否正确设置
    virtual ::grpc::Status PostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostFrictionWheelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostFrictionWheelRaw(context, request, cq));
    }
    // 向服务器传输停止信息 传回是否正确设置
    virtual ::grpc::Status PostStop(::grpc::ClientContext* context, const ::communication::Stop& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostStop(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostStop(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostStopRaw(context, request, cq));
    }
    // 向服务器传输子弹开关信息 传回是否正确设置
    virtual ::grpc::Status PostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::communication::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> AsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(AsyncPostBulletRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>> PrepareAsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>>(PrepareAsyncPostBulletRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // 向服务器索取血量信息 传回血量信息
      virtual void GetBlood(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Blood* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlood(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Blood* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取弹药量信息 传回弹药量信息
      virtual void GetAmmunition(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Ammunition* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAmmunition(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Ammunition* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取位姿信息 传回位姿信息
      virtual void GetPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Posture* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Posture* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取枪口朝向信息 传回枪口朝向信息
      virtual void GetGunPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::GunPosture* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGunPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::GunPosture* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取速度信息 传回速度信息
      virtual void GetVelocity(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Velocity* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVelocity(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Velocity* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取受击信息 传回受击信息
      virtual void GetAffected(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Affected* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAffected(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Affected* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器索取位置信息 传回位置信息
      virtual void GetObjectDection(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::ObjectDection* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetObjectDection(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::ObjectDection* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输血量信息 传回是否正确设置
      virtual void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输弹药量信息 传回是否正确设置
      virtual void PostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输目的地信息 传回是否正确设置
      virtual void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输摩擦轮信息 传回是否正确设置
      virtual void PostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输停止信息 传回是否正确设置
      virtual void PostStop(::grpc::ClientContext* context, const ::communication::Stop* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostStop(::grpc::ClientContext* context, const ::communication::Stop* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 向服务器传输子弹开关信息 传回是否正确设置
      virtual void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>* AsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Blood>* PrepareAsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Ammunition>* AsyncGetAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Ammunition>* PrepareAsyncGetAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>* AsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Posture>* PrepareAsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::GunPosture>* AsyncGetGunPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::GunPosture>* PrepareAsyncGetGunPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>* AsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Velocity>* PrepareAsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Affected>* AsyncGetAffectedRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Affected>* PrepareAsyncGetAffectedRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>* AsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::ObjectDection>* PrepareAsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostFrictionWheelRaw(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostFrictionWheelRaw(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostStopRaw(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostStopRaw(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* AsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::communication::Response>* PrepareAsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetBlood(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Blood* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>> AsyncGetBlood(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>>(AsyncGetBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>> PrepareAsyncGetBlood(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Blood>>(PrepareAsyncGetBloodRaw(context, request, cq));
    }
    ::grpc::Status GetAmmunition(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Ammunition* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Ammunition>> AsyncGetAmmunition(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Ammunition>>(AsyncGetAmmunitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Ammunition>> PrepareAsyncGetAmmunition(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Ammunition>>(PrepareAsyncGetAmmunitionRaw(context, request, cq));
    }
    ::grpc::Status GetPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Posture* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>> AsyncGetPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>>(AsyncGetPostureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>> PrepareAsyncGetPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Posture>>(PrepareAsyncGetPostureRaw(context, request, cq));
    }
    ::grpc::Status GetGunPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::GunPosture* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GunPosture>> AsyncGetGunPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GunPosture>>(AsyncGetGunPostureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GunPosture>> PrepareAsyncGetGunPosture(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::GunPosture>>(PrepareAsyncGetGunPostureRaw(context, request, cq));
    }
    ::grpc::Status GetVelocity(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Velocity* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>> AsyncGetVelocity(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>>(AsyncGetVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>> PrepareAsyncGetVelocity(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Velocity>>(PrepareAsyncGetVelocityRaw(context, request, cq));
    }
    ::grpc::Status GetAffected(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::Affected* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Affected>> AsyncGetAffected(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Affected>>(AsyncGetAffectedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Affected>> PrepareAsyncGetAffected(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Affected>>(PrepareAsyncGetAffectedRaw(context, request, cq));
    }
    ::grpc::Status GetObjectDection(::grpc::ClientContext* context, const ::communication::Request& request, ::communication::ObjectDection* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>> AsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>>(AsyncGetObjectDectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>> PrepareAsyncGetObjectDection(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>>(PrepareAsyncGetObjectDectionRaw(context, request, cq));
    }
    ::grpc::Status PostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostBloodRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostBlood(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostBloodRaw(context, request, cq));
    }
    ::grpc::Status PostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostAmmunitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostAmmunitionRaw(context, request, cq));
    }
    ::grpc::Status PostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostDestinationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostDestination(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostDestinationRaw(context, request, cq));
    }
    ::grpc::Status PostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostFrictionWheelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostFrictionWheelRaw(context, request, cq));
    }
    ::grpc::Status PostStop(::grpc::ClientContext* context, const ::communication::Stop& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostStop(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostStop(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostStopRaw(context, request, cq));
    }
    ::grpc::Status PostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::communication::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> AsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(AsyncPostBulletRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>> PrepareAsyncPostBullet(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::communication::Response>>(PrepareAsyncPostBulletRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetBlood(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Blood* response, std::function<void(::grpc::Status)>) override;
      void GetBlood(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Blood* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAmmunition(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Ammunition* response, std::function<void(::grpc::Status)>) override;
      void GetAmmunition(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Ammunition* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Posture* response, std::function<void(::grpc::Status)>) override;
      void GetPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Posture* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGunPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::GunPosture* response, std::function<void(::grpc::Status)>) override;
      void GetGunPosture(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::GunPosture* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVelocity(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Velocity* response, std::function<void(::grpc::Status)>) override;
      void GetVelocity(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Velocity* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAffected(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Affected* response, std::function<void(::grpc::Status)>) override;
      void GetAffected(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::Affected* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetObjectDection(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::ObjectDection* response, std::function<void(::grpc::Status)>) override;
      void GetObjectDection(::grpc::ClientContext* context, const ::communication::Request* request, ::communication::ObjectDection* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostBlood(::grpc::ClientContext* context, const ::communication::Blood* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostAmmunition(::grpc::ClientContext* context, const ::communication::Ammunition* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostDestination(::grpc::ClientContext* context, const ::communication::Destination* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostFrictionWheel(::grpc::ClientContext* context, const ::communication::FrictionWheel* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostStop(::grpc::ClientContext* context, const ::communication::Stop* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostStop(::grpc::ClientContext* context, const ::communication::Stop* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, std::function<void(::grpc::Status)>) override;
      void PostBullet(::grpc::ClientContext* context, const ::communication::Bullet* request, ::communication::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::communication::Blood>* AsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Blood>* PrepareAsyncGetBloodRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Ammunition>* AsyncGetAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Ammunition>* PrepareAsyncGetAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Posture>* AsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Posture>* PrepareAsyncGetPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::GunPosture>* AsyncGetGunPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::GunPosture>* PrepareAsyncGetGunPostureRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Velocity>* AsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Velocity>* PrepareAsyncGetVelocityRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Affected>* AsyncGetAffectedRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Affected>* PrepareAsyncGetAffectedRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>* AsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::ObjectDection>* PrepareAsyncGetObjectDectionRaw(::grpc::ClientContext* context, const ::communication::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostBloodRaw(::grpc::ClientContext* context, const ::communication::Blood& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostAmmunitionRaw(::grpc::ClientContext* context, const ::communication::Ammunition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostDestinationRaw(::grpc::ClientContext* context, const ::communication::Destination& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostFrictionWheelRaw(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostFrictionWheelRaw(::grpc::ClientContext* context, const ::communication::FrictionWheel& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostStopRaw(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostStopRaw(::grpc::ClientContext* context, const ::communication::Stop& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* AsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::communication::Response>* PrepareAsyncPostBulletRaw(::grpc::ClientContext* context, const ::communication::Bullet& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlood_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAmmunition_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPosture_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGunPosture_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVelocity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAffected_;
    const ::grpc::internal::RpcMethod rpcmethod_GetObjectDection_;
    const ::grpc::internal::RpcMethod rpcmethod_PostBlood_;
    const ::grpc::internal::RpcMethod rpcmethod_PostAmmunition_;
    const ::grpc::internal::RpcMethod rpcmethod_PostDestination_;
    const ::grpc::internal::RpcMethod rpcmethod_PostFrictionWheel_;
    const ::grpc::internal::RpcMethod rpcmethod_PostStop_;
    const ::grpc::internal::RpcMethod rpcmethod_PostBullet_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 向服务器索取血量信息 传回血量信息
    virtual ::grpc::Status GetBlood(::grpc::ServerContext* context, const ::communication::Request* request, ::communication::Blood* response);
    // 向服务器索取弹药量信息 传回弹药量信息
    virtual ::grpc::Status GetAmmunition(::grpc::ServerContext* context, const ::communication::Request* request, ::communication::Ammunition* response);
    // 向服务器索取位姿信息 传回位姿信息
    virtual ::grpc::Status GetPosture(::grpc::ServerContext* context, const ::communication::Request* request, ::communication::Posture* response);
    // 向服务器索取枪口朝向信息 传回枪口朝向信息
    virtual ::grpc::Status GetGunPosture(::grpc::ServerContext* context, const ::communication::Request* request, ::communication::GunPosture* response);
    // 向服务器索取速度信息 传回速度信息
    virtual ::grpc::Status GetVelocity(::grpc::ServerContext* context, const ::communication::Request* request, ::communication::Velocity* response);
    // 向服务器索取受击信息 传回受击信息
    virtual ::grpc::Status GetAffected(::grpc::ServerContext* context, const ::communication::Request* request, ::communication::Affected* response);
    // 向服务器索取位置信息 传回位置信息
    virtual ::grpc::Status GetObjectDection(::grpc::ServerContext* context, const ::communication::Request* request, ::communication::ObjectDection* response);
    // 向服务器传输血量信息 传回是否正确设置
    virtual ::grpc::Status PostBlood(::grpc::ServerContext* context, const ::communication::Blood* request, ::communication::Response* response);
    // 向服务器传输弹药量信息 传回是否正确设置
    virtual ::grpc::Status PostAmmunition(::grpc::ServerContext* context, const ::communication::Ammunition* request, ::communication::Response* response);
    // 向服务器传输目的地信息 传回是否正确设置
    virtual ::grpc::Status PostDestination(::grpc::ServerContext* context, const ::communication::Destination* request, ::communication::Response* response);
    // 向服务器传输摩擦轮信息 传回是否正确设置
    virtual ::grpc::Status PostFrictionWheel(::grpc::ServerContext* context, const ::communication::FrictionWheel* request, ::communication::Response* response);
    // 向服务器传输停止信息 传回是否正确设置
    virtual ::grpc::Status PostStop(::grpc::ServerContext* context, const ::communication::Stop* request, ::communication::Response* response);
    // 向服务器传输子弹开关信息 传回是否正确设置
    virtual ::grpc::Status PostBullet(::grpc::ServerContext* context, const ::communication::Bullet* request, ::communication::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlood() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlood(::grpc::ServerContext* context, ::communication::Request* request, ::grpc::ServerAsyncResponseWriter< ::communication::Blood>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAmmunition() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Ammunition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAmmunition(::grpc::ServerContext* context, ::communication::Request* request, ::grpc::ServerAsyncResponseWriter< ::communication::Ammunition>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPosture() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosture(::grpc::ServerContext* context, ::communication::Request* request, ::grpc::ServerAsyncResponseWriter< ::communication::Posture>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGunPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGunPosture() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetGunPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGunPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::GunPosture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGunPosture(::grpc::ServerContext* context, ::communication::Request* request, ::grpc::ServerAsyncResponseWriter< ::communication::GunPosture>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVelocity() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVelocity(::grpc::ServerContext* context, ::communication::Request* request, ::grpc::ServerAsyncResponseWriter< ::communication::Velocity>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAffected : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAffected() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetAffected() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAffected(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Affected* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAffected(::grpc::ServerContext* context, ::communication::Request* request, ::grpc::ServerAsyncResponseWriter< ::communication::Affected>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectDection(::grpc::ServerContext* context, ::communication::Request* request, ::grpc::ServerAsyncResponseWriter< ::communication::ObjectDection>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostBlood() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBlood(::grpc::ServerContext* context, ::communication::Blood* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostAmmunition() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PostAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Ammunition* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAmmunition(::grpc::ServerContext* context, ::communication::Ammunition* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostDestination() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostDestination(::grpc::ServerContext* context, ::communication::Destination* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostFrictionWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostFrictionWheel() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_PostFrictionWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFrictionWheel(::grpc::ServerContext* /*context*/, const ::communication::FrictionWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostFrictionWheel(::grpc::ServerContext* context, ::communication::FrictionWheel* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostStop() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_PostStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStop(::grpc::ServerContext* /*context*/, const ::communication::Stop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostStop(::grpc::ServerContext* context, ::communication::Stop* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PostBullet() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBullet(::grpc::ServerContext* context, ::communication::Bullet* request, ::grpc::ServerAsyncResponseWriter< ::communication::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetBlood<WithAsyncMethod_GetAmmunition<WithAsyncMethod_GetPosture<WithAsyncMethod_GetGunPosture<WithAsyncMethod_GetVelocity<WithAsyncMethod_GetAffected<WithAsyncMethod_GetObjectDection<WithAsyncMethod_PostBlood<WithAsyncMethod_PostAmmunition<WithAsyncMethod_PostDestination<WithAsyncMethod_PostFrictionWheel<WithAsyncMethod_PostStop<WithAsyncMethod_PostBullet<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBlood() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Blood>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Request* request, ::communication::Blood* response) { return this->GetBlood(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlood(
        ::grpc::MessageAllocator< ::communication::Request, ::communication::Blood>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Blood>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Blood* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAmmunition() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Ammunition>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Request* request, ::communication::Ammunition* response) { return this->GetAmmunition(context, request, response); }));}
    void SetMessageAllocatorFor_GetAmmunition(
        ::grpc::MessageAllocator< ::communication::Request, ::communication::Ammunition>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Ammunition>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Ammunition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAmmunition(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Ammunition* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPosture() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Posture>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Request* request, ::communication::Posture* response) { return this->GetPosture(context, request, response); }));}
    void SetMessageAllocatorFor_GetPosture(
        ::grpc::MessageAllocator< ::communication::Request, ::communication::Posture>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Posture>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPosture(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Posture* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGunPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGunPosture() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::GunPosture>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Request* request, ::communication::GunPosture* response) { return this->GetGunPosture(context, request, response); }));}
    void SetMessageAllocatorFor_GetGunPosture(
        ::grpc::MessageAllocator< ::communication::Request, ::communication::GunPosture>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::GunPosture>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGunPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGunPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::GunPosture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGunPosture(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::GunPosture* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVelocity() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Velocity>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Request* request, ::communication::Velocity* response) { return this->GetVelocity(context, request, response); }));}
    void SetMessageAllocatorFor_GetVelocity(
        ::grpc::MessageAllocator< ::communication::Request, ::communication::Velocity>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Velocity>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Velocity* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAffected : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAffected() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Affected>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Request* request, ::communication::Affected* response) { return this->GetAffected(context, request, response); }));}
    void SetMessageAllocatorFor_GetAffected(
        ::grpc::MessageAllocator< ::communication::Request, ::communication::Affected>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::Affected>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAffected() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAffected(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Affected* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAffected(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Affected* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::ObjectDection>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Request* request, ::communication::ObjectDection* response) { return this->GetObjectDection(context, request, response); }));}
    void SetMessageAllocatorFor_GetObjectDection(
        ::grpc::MessageAllocator< ::communication::Request, ::communication::ObjectDection>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Request, ::communication::ObjectDection>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetObjectDection(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::ObjectDection* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostBlood() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Blood, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Blood* request, ::communication::Response* response) { return this->PostBlood(context, request, response); }));}
    void SetMessageAllocatorFor_PostBlood(
        ::grpc::MessageAllocator< ::communication::Blood, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Blood, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostAmmunition() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Ammunition, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Ammunition* request, ::communication::Response* response) { return this->PostAmmunition(context, request, response); }));}
    void SetMessageAllocatorFor_PostAmmunition(
        ::grpc::MessageAllocator< ::communication::Ammunition, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Ammunition, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Ammunition* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostAmmunition(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Ammunition* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostDestination() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Destination, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Destination* request, ::communication::Response* response) { return this->PostDestination(context, request, response); }));}
    void SetMessageAllocatorFor_PostDestination(
        ::grpc::MessageAllocator< ::communication::Destination, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Destination, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostDestination(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostFrictionWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostFrictionWheel() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::FrictionWheel, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::FrictionWheel* request, ::communication::Response* response) { return this->PostFrictionWheel(context, request, response); }));}
    void SetMessageAllocatorFor_PostFrictionWheel(
        ::grpc::MessageAllocator< ::communication::FrictionWheel, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::FrictionWheel, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostFrictionWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFrictionWheel(::grpc::ServerContext* /*context*/, const ::communication::FrictionWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostFrictionWheel(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::FrictionWheel* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostStop() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Stop, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Stop* request, ::communication::Response* response) { return this->PostStop(context, request, response); }));}
    void SetMessageAllocatorFor_PostStop(
        ::grpc::MessageAllocator< ::communication::Stop, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Stop, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStop(::grpc::ServerContext* /*context*/, const ::communication::Stop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostStop(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Stop* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PostBullet() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::communication::Bullet, ::communication::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::communication::Bullet* request, ::communication::Response* response) { return this->PostBullet(context, request, response); }));}
    void SetMessageAllocatorFor_PostBullet(
        ::grpc::MessageAllocator< ::communication::Bullet, ::communication::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::communication::Bullet, ::communication::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBullet(
      ::grpc::CallbackServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetBlood<WithCallbackMethod_GetAmmunition<WithCallbackMethod_GetPosture<WithCallbackMethod_GetGunPosture<WithCallbackMethod_GetVelocity<WithCallbackMethod_GetAffected<WithCallbackMethod_GetObjectDection<WithCallbackMethod_PostBlood<WithCallbackMethod_PostAmmunition<WithCallbackMethod_PostDestination<WithCallbackMethod_PostFrictionWheel<WithCallbackMethod_PostStop<WithCallbackMethod_PostBullet<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlood() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAmmunition() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Ammunition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPosture() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGunPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGunPosture() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetGunPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGunPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::GunPosture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVelocity() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAffected : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAffected() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetAffected() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAffected(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Affected* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostBlood() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostAmmunition() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PostAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Ammunition* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostDestination() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostFrictionWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostFrictionWheel() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_PostFrictionWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFrictionWheel(::grpc::ServerContext* /*context*/, const ::communication::FrictionWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostStop() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_PostStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStop(::grpc::ServerContext* /*context*/, const ::communication::Stop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PostBullet() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlood() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlood(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAmmunition() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Ammunition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAmmunition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPosture() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosture(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGunPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGunPosture() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetGunPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGunPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::GunPosture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGunPosture(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVelocity() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVelocity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAffected : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAffected() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetAffected() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAffected(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Affected* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAffected(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectDection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostBlood() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBlood(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostAmmunition() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PostAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Ammunition* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostAmmunition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostDestination() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostDestination(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostFrictionWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostFrictionWheel() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_PostFrictionWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFrictionWheel(::grpc::ServerContext* /*context*/, const ::communication::FrictionWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostFrictionWheel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostStop() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_PostStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStop(::grpc::ServerContext* /*context*/, const ::communication::Stop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PostBullet() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPostBullet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBlood() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlood(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAmmunition() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAmmunition(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Ammunition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAmmunition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPosture() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPosture(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPosture(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGunPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGunPosture() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGunPosture(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGunPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGunPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::GunPosture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGunPosture(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVelocity() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVelocity(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAffected : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAffected() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAffected(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAffected() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAffected(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Affected* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAffected(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetObjectDection(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetObjectDection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostBlood() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostBlood(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBlood(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostAmmunition() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostAmmunition(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Ammunition* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostAmmunition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostDestination() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostDestination(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostDestination(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostFrictionWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostFrictionWheel() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostFrictionWheel(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostFrictionWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostFrictionWheel(::grpc::ServerContext* /*context*/, const ::communication::FrictionWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostFrictionWheel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostStop() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostStop(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostStop(::grpc::ServerContext* /*context*/, const ::communication::Stop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostStop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PostBullet() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PostBullet(context, request, response); }));
    }
    ~WithRawCallbackMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PostBullet(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlood() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Request, ::communication::Blood>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Request, ::communication::Blood>* streamer) {
                       return this->StreamedGetBlood(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlood(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Blood* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlood(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Request,::communication::Blood>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAmmunition() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Request, ::communication::Ammunition>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Request, ::communication::Ammunition>* streamer) {
                       return this->StreamedGetAmmunition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Ammunition* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAmmunition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Request,::communication::Ammunition>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPosture() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Request, ::communication::Posture>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Request, ::communication::Posture>* streamer) {
                       return this->StreamedGetPosture(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Posture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPosture(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Request,::communication::Posture>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGunPosture : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGunPosture() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Request, ::communication::GunPosture>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Request, ::communication::GunPosture>* streamer) {
                       return this->StreamedGetGunPosture(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGunPosture() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGunPosture(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::GunPosture* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGunPosture(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Request,::communication::GunPosture>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVelocity() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Request, ::communication::Velocity>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Request, ::communication::Velocity>* streamer) {
                       return this->StreamedGetVelocity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVelocity(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Velocity* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVelocity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Request,::communication::Velocity>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAffected : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAffected() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Request, ::communication::Affected>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Request, ::communication::Affected>* streamer) {
                       return this->StreamedGetAffected(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAffected() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAffected(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::Affected* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAffected(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Request,::communication::Affected>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetObjectDection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetObjectDection() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Request, ::communication::ObjectDection>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Request, ::communication::ObjectDection>* streamer) {
                       return this->StreamedGetObjectDection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetObjectDection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetObjectDection(::grpc::ServerContext* /*context*/, const ::communication::Request* /*request*/, ::communication::ObjectDection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetObjectDection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Request,::communication::ObjectDection>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostBlood : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostBlood() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Blood, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Blood, ::communication::Response>* streamer) {
                       return this->StreamedPostBlood(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostBlood() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostBlood(::grpc::ServerContext* /*context*/, const ::communication::Blood* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostBlood(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Blood,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostAmmunition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostAmmunition() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Ammunition, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Ammunition, ::communication::Response>* streamer) {
                       return this->StreamedPostAmmunition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostAmmunition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostAmmunition(::grpc::ServerContext* /*context*/, const ::communication::Ammunition* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostAmmunition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Ammunition,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostDestination : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostDestination() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Destination, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Destination, ::communication::Response>* streamer) {
                       return this->StreamedPostDestination(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostDestination() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostDestination(::grpc::ServerContext* /*context*/, const ::communication::Destination* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostDestination(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Destination,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostFrictionWheel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostFrictionWheel() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::FrictionWheel, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::FrictionWheel, ::communication::Response>* streamer) {
                       return this->StreamedPostFrictionWheel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostFrictionWheel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostFrictionWheel(::grpc::ServerContext* /*context*/, const ::communication::FrictionWheel* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostFrictionWheel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::FrictionWheel,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostStop() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Stop, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Stop, ::communication::Response>* streamer) {
                       return this->StreamedPostStop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostStop(::grpc::ServerContext* /*context*/, const ::communication::Stop* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Stop,::communication::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PostBullet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PostBullet() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::communication::Bullet, ::communication::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::communication::Bullet, ::communication::Response>* streamer) {
                       return this->StreamedPostBullet(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PostBullet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PostBullet(::grpc::ServerContext* /*context*/, const ::communication::Bullet* /*request*/, ::communication::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPostBullet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::communication::Bullet,::communication::Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetBlood<WithStreamedUnaryMethod_GetAmmunition<WithStreamedUnaryMethod_GetPosture<WithStreamedUnaryMethod_GetGunPosture<WithStreamedUnaryMethod_GetVelocity<WithStreamedUnaryMethod_GetAffected<WithStreamedUnaryMethod_GetObjectDection<WithStreamedUnaryMethod_PostBlood<WithStreamedUnaryMethod_PostAmmunition<WithStreamedUnaryMethod_PostDestination<WithStreamedUnaryMethod_PostFrictionWheel<WithStreamedUnaryMethod_PostStop<WithStreamedUnaryMethod_PostBullet<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetBlood<WithStreamedUnaryMethod_GetAmmunition<WithStreamedUnaryMethod_GetPosture<WithStreamedUnaryMethod_GetGunPosture<WithStreamedUnaryMethod_GetVelocity<WithStreamedUnaryMethod_GetAffected<WithStreamedUnaryMethod_GetObjectDection<WithStreamedUnaryMethod_PostBlood<WithStreamedUnaryMethod_PostAmmunition<WithStreamedUnaryMethod_PostDestination<WithStreamedUnaryMethod_PostFrictionWheel<WithStreamedUnaryMethod_PostStop<WithStreamedUnaryMethod_PostBullet<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace communication


#endif  // GRPC_communication_2eproto__INCLUDED
